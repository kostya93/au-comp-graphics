<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <script src="libs/gl-matrix.js"></script>
</head>
<body style="margin:0;">
<canvas width = "600" height = "600" id = "my_Canvas"></canvas>
<input type="number" id="iterations_in"> iterations: <span id="iterations_out">100</span>

<script>
    initInput();
    var canvas = document.getElementById('my_Canvas');

    bindWheelListener(canvas);

    var hold = false;
    var curX = 0, curY = 0;
    canvas.onmousedown = mouseDown;
    canvas.onmousemove = mouseMove;
    canvas.onmouseup = mouseUp;

    var gl = canvas.getContext('webgl');

    var shaderProgram = initShaders();

    var translationLocation = gl.getUniformLocation(shaderProgram, "u_translation");
    var maxIterLocation = gl.getUniformLocation(shaderProgram, 'max_iterations');
    var scaleLocation = gl.getUniformLocation(shaderProgram, "u_scale");
    var max_iter = 100;
    var translation = [0.0, 0.0, 0.0, 0.0];
    var scale = [1.0, 1.0, 1.0, 1.0];

    createGeometryAndBindToBuffer();

    bindTexture();

    function createGeometryAndBindToBuffer() {
        var vertex_buffer = gl.createBuffer();

        // Bind an empty array buffer to it
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

        // Pass the vertices data to the buffer
        var positions = [
            -1, -1,
            -1, 1,
            1, 1,
            -1, -1,
            1, 1,
            1, -1
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
    }

    function initShaders() {
        var vertCode = `
                attribute vec4 a_position;
                uniform vec4 u_translation;
                uniform vec4 u_scale;
                varying vec4 v_texCoord;
                void main(void) {
                  gl_Position = a_position*u_scale + u_translation;
                  v_texCoord = a_position;
                }
                `;

        //Create a vertex shader object
        var vertShader = gl.createShader(gl.VERTEX_SHADER);

        //Attach vertex shader source code
        gl.shaderSource(vertShader, vertCode);

        //Compile the vertex shader
        gl.compileShader(vertShader);

        //Fragment shader source code
        var fragCode = `
                precision highp float;
                uniform sampler2D spect;

                uniform vec4 u_translation;
                uniform vec4 u_scale;
                uniform int max_iterations;

                varying vec4 v_texCoord;
                void main(void) {
                  float clr = 0.0;

                  float e = 4.0;
                  const int MAX_ITER = 100;

                  float x = v_texCoord.x*2.0;
                  float y = v_texCoord.y*2.0;

                  float rt = x;
                  float it = y;

                  float arg = x*x + y*y;

                  int iter=0;

                  for (int i=0; i <= MAX_ITER; i++) {
                    iter=i;
                    if (arg >= e || i >= max_iterations) {
                      break;
                    }
                    float rt2 = rt*rt - it*it + x;
                    it = 2.0*it*rt + y;
                    rt = rt2;
                    arg = rt*rt + it*it;
                  }

                  clr = float(iter)/float(max_iterations);

                  vec4 color;

                  if (iter == max_iterations) {
                    color = vec4(0.0, 0.0, 0.0, 1.0);
                  } else {
                    color = texture2D(spect, vec2(clr, 0.0));
                  }
                  gl_FragColor = color;
                }
                `;

        // Create fragment shader object
        var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

        // Attach fragment shader source code
        gl.shaderSource(fragShader, fragCode);

        // Compile the fragment shader
        gl.compileShader(fragShader);

        console.log(gl.getShaderInfoLog(fragShader));
        console.log(gl.getShaderInfoLog(vertShader));

        // Create a shader program object to store combined shader program
        var sProgram = gl.createProgram();

        // Attach a vertex shader
        gl.attachShader(sProgram, vertShader);

        // Attach a fragment shader
        gl.attachShader(sProgram, fragShader);

        // Link both programs
        gl.linkProgram(sProgram);

        // Use the combined shader program object
        gl.useProgram(sProgram);
        console.log(gl.getProgramInfoLog(sProgram));

        return sProgram;
    }

    var draw = window.setInterval(function () {

        // Unbind the buffer

        /* Step3: Create and compile Shader programs */

        /* Step 4: Associate the shader programs to buffer objects */

        //Bind vertex buffer object

        //Get the attribute location
        var coord = gl.getAttribLocation(shaderProgram, "a_position");

        //point an attribute to the currently bound VBO
        gl.vertexAttribPointer(coord, 2, gl.FLOAT, false, 0, 0);

        //Enable the attribute
        gl.enableVertexAttribArray(coord);
        /* Step5: Drawing the required object (triangle) */

        // Clear the canvas
        gl.clearColor(0.0, 0.0, 0.0, 1.0);

        // Enable the depth test
//        gl.enable(gl.DEPTH_TEST);

        // Clear the color buffer bit
//        gl.clear(gl.COLOR_BUFFER_BIT);

        // Set the view port
        gl.viewport(0,0,canvas.width,canvas.height);

        // Set the translation.
        gl.uniform4fv(translationLocation, translation);

        // Set the scale.
        gl.uniform4fv(scaleLocation, scale);

        gl.uniform1i(maxIterLocation, max_iter);

        // Draw the triangle
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }, 50);


    function bindTexture() {
        var tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        var oneDTextureTexels = new Uint8Array([
            255,0,0,255,
            255,128,0,255,
            255,255,0,255,
            128,255,0,255,
            0,255,0,255,
            0,255,255,255,
            0,0,255,255,
            127,0,255,255,
        ]);

        var width = 8;
        var height = 1;
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                oneDTextureTexels);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    }

    function bindWheelListener(elem) {
        if (elem.addEventListener) {
            if ('onwheel' in document) {
                // IE9+, FF17+
                elem.addEventListener("wheel", onWheel);
            } else if ('onmousewheel' in document) {
                // устаревший вариант события
                elem.addEventListener("mousewheel", onWheel);
            } else {
                // Firefox < 17
                elem.addEventListener("MozMousePixelScroll", onWheel);
            }
        } else { // IE8-
            elem.attachEvent("onmousewheel", onWheel);
        }


        // Это решение предусматривает поддержку IE8-
        function onWheel(e) {
            e = e || window.event;

            // deltaY, detail содержат пиксели
            // wheelDelta не дает возможность узнать количество пикселей
            // onwheel || MozMousePixelScroll || onmousewheel
            var delta = e.deltaY || e.detail || e.wheelDelta;

            var info = document.getElementById('position');
            var delta_scale = - delta/1000.0;
            var old_scale_x = scale[0];
            var old_scale_y = scale[1];
            scale[0] = scale[1] = scale[0]*(1 + delta_scale);
            if (scale[0] < 0.95) {
                scale[0] = scale[1] = 1.0;
            } else {
                var DXP = (e.x - (canvas.width/2.0)*(translation[0] + 1.0));
                var dXP = (DXP/old_scale_x)*scale[0] - DXP;
                var dXC = dXP/(canvas.width/2.0);
                translation[0] -= dXC;

                var DYP = (e.y - (canvas.height/2.0)*(1.0 - translation[1]));
                var dYP = DYP*((scale[1]/old_scale_y) - 1.0);
                var dYC = dYP/(canvas.height/2.0);
                translation[1] += dYC;
            }
            e.preventDefault ? e.preventDefault() : (e.returnValue = false);
        }
    }

    function mouseDown() {
        hold = true;
        curX = window.event.x;
        curY = window.event.y;
    }

    function mouseUp() {
        hold = false;
    }

    function mouseMove() {
        if (!hold) {
            return;
        }
        translation[0] -= ((curX - window.event.x)/canvas.width)*2;
        translation[1] += ((curY - window.event.y)/canvas.height)*2;
        curX = window.event.x;
        curY = window.event.y;
    }

    function initInput() {
        var input = document.getElementById("iterations_in");
        input.oninput = function () {
            var iter = input.value;
            if (iter < 1) {
                iter = 1;
            }
            if (iter > 100) {
                iter = 100;
            }
            var iter_out = document.getElementById("iterations_out");
            iter_out.innerHTML = iter;
            max_iter = iter;
            translation = [0.0, 0.0, 0.0, 0.0];
            scale = [1.0, 1.0, 1.0, 1.0];
            createGeometryAndBindToBuffer();
        };
    }


</script>

</body>
</html>